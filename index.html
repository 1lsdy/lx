<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>二十四节气 - 粒子交互可视化</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #e0e0e0; 
            overflow: hidden;
            font-family: 'Noto Serif SC', 'Songti SC', serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

<canvas id="canvas1"></canvas>

<script>
// 检测是否为移动端 (屏幕宽度小于 768px)
const isMobile = window.innerWidth < 768;

/**
 * 动态配置参数
 */
const CONFIG = {
    // --- 粒子数量控制 ---
    // 移动端保持适中数量，确保文字清晰
    petalCount: isMobile ? 2500 : 6000,
    bgCount: isMobile ? 1500 : 3500,
    ringCount: isMobile ? 2000 : 4000,
    outerBorderCount: isMobile ? 800 : 1200,
    
    // --- 字体与采样 ---
    // 关键修复：移动端采样间隔设为1，不再稀疏，确保文字完整显示
    textGap: 1,               
    
    // --- 视觉参数 ---
    particleSize: isMobile ? 1.4 : 1.4, // 保持粒子可见度
    returnSpeed: 0.08, // 粒子归位速度
    friction: 0.90,    // 摩擦力
    
    // --- 动画参数 ---
    rotationSpeed: 0.0005, // 稍微调快一点旋转速度，避免看起来像静止
    
    colors: {
        winter: '#1B2640',    // 冬
        spring: '#009E73',    // 春
        summer: '#D94430',    // 夏
        autumn: '#FFFFFF',    // 秋
        bgInner: '#E6A54E',   // 金黄
        textRing: '#FFFFFF',  // 圆环白
        outerBorder: '#E6A54E', // 外圈黄
        text: '#333333'       // 文字黑
    }
};

const canvas = document.getElementById('canvas1');
const ctx = canvas.getContext('2d');

let particlesArray = [];
let solarTerms = [
    "立春", "雨水", "惊蛰", "春分", "清明", "谷雨",
    "立夏", "小满", "芒种", "夏至", "小暑", "大暑",
    "立秋", "处暑", "白露", "秋分", "寒露", "霜降",
    "立冬", "小雪", "大雪", "冬至", "小寒", "大寒"
];

let angleGlobal = 0; 

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// 窗口大小改变时重置
let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        // 简单重载以适配横竖屏
        const newIsMobile = window.innerWidth < 768;
        if (newIsMobile !== isMobile) {
            location.reload(); 
        } else {
            init();
        }
    }, 200);
});

class Particle {
    constructor(x, y, color) {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.targetX = x; 
        this.targetY = y;
        this.color = color;
        this.size = CONFIG.particleSize;
        
        this.vx = 0;
        this.vy = 0;
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }

    update(centerX, centerY, cos, sin) {
        // 计算旋转后的目标位置
        const rotatedX = (this.targetX * cos) - (this.targetY * sin);
        const rotatedY = (this.targetX * sin) + (this.targetY * cos);

        let destX = centerX + rotatedX;
        let destY = centerY + rotatedY;

        // 简化的物理归位逻辑
        if (Math.abs(this.x - destX) > 0.5 || Math.abs(this.y - destY) > 0.5) {
            let dx = destX - this.x;
            let dy = destY - this.y;
            this.vx += dx * CONFIG.returnSpeed * 0.1;
            this.vy += dy * CONFIG.returnSpeed * 0.1;
            this.vx *= CONFIG.friction;
            this.vy *= CONFIG.friction;
            this.x += this.vx;
            this.y += this.vy;
        } else {
            // 归位后锁定位置，跟随旋转
            this.x = destX;
            this.y = destY;
            this.vx = 0;
            this.vy = 0;
        }

        this.draw();
    }
}

function init() {
    particlesArray = [];
    
    const minDimension = Math.min(canvas.width, canvas.height);
    
    // --- 响应式尺寸计算 ---
    // 关键修复：放大移动端比例
    // 移动端：半径设为宽度的 46% (直径 92%)，这会让边缘非常靠近屏幕两侧
    // 电脑端：保持 35%
    const radiusScale = isMobile ? 0.46 : 0.35; 
    const radius = minDimension * radiusScale; 
    
    // 动态计算圆环参数
    const ringGap = radius * 0.05; // 间隙
    // 移动端圆环稍微宽一点点以容纳文字
    const ringWidth = radius * (isMobile ? 0.28 : 0.25); 
    
    const ringInnerR = radius + ringGap;
    const ringOuterR = radius + ringGap + ringWidth;

    // 1. 生成花瓣
    for (let i = 0; i < CONFIG.petalCount; i++) {
        let theta = Math.random() * Math.PI * 2;
        let rMax = Math.abs(Math.cos(2 * theta)) * radius;
        let r = Math.sqrt(Math.random()) * rMax;
        
        let x = r * Math.cos(theta);
        let y = r * Math.sin(theta);

        let color = CONFIG.colors.bgInner; 
        let deg = (theta * 180 / Math.PI + 360) % 360;
        
        if (deg >= 315 || deg < 45) color = CONFIG.colors.spring;
        else if (deg >= 45 && deg < 135) color = CONFIG.colors.summer;
        else if (deg >= 135 && deg < 225) color = CONFIG.colors.autumn;
        else if (deg >= 225 && deg < 315) color = CONFIG.colors.winter;

        particlesArray.push(new Particle(x, y, color));
    }

    // 2. 生成背景圆盘 (填充到 ringInnerR)
    let bgParticlesCreated = 0;
    while (bgParticlesCreated < CONFIG.bgCount) {
        let theta = Math.random() * Math.PI * 2;
        let r = Math.sqrt(Math.random()) * ringInnerR; 
        
        let petalBoundary = Math.abs(Math.cos(2 * theta)) * radius;

        if (r < petalBoundary * 1.02) {
            continue;
        }
        
        let x = r * Math.cos(theta);
        let y = r * Math.sin(theta);
        
        particlesArray.push(new Particle(x, y, CONFIG.colors.bgInner));
        bgParticlesCreated++;
    }

    // 3. 生成外圈文字环
    for (let i = 0; i < CONFIG.ringCount; i++) {
        let theta = Math.random() * Math.PI * 2;
        let r = ringInnerR + Math.random() * (ringOuterR - ringInnerR);
        let x = r * Math.cos(theta);
        let y = r * Math.sin(theta);
        particlesArray.push(new Particle(x, y, CONFIG.colors.textRing));
    }

    // 4. 外围黄色装饰圈
    const borderR = ringOuterR + (isMobile ? 1 : 5);
    for (let i = 0; i < CONFIG.outerBorderCount; i++) {
        let theta = Math.random() * Math.PI * 2;
        let r = borderR + Math.random() * (isMobile ? 2 : 3); 
        let x = r * Math.cos(theta);
        let y = r * Math.sin(theta);
        particlesArray.push(new Particle(x, y, CONFIG.colors.outerBorder));
    }

    // 5. 生成文字粒子
    createSolarTermsParticles(ringInnerR, ringOuterR);
}

function createSolarTermsParticles(innerR, outerR) {
    const textRadius = (innerR + outerR) / 2;
    
    // 动态调整字体大小
    // 关键修复：字体稍微调大一点点，保证可读性
    const fontSize = isMobile ? 16 : 20;
    // 增加临时画布大小，防止文字截断
    const canvasW = 120;
    const canvasH = 60;

    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = canvasW;
    tempCanvas.height = canvasH;

    solarTerms.forEach((term, index) => {
        let angle = (index - 3) * 15 * (Math.PI / 180);
        
        let x = textRadius * Math.cos(angle);
        let y = textRadius * Math.sin(angle);
        
        tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
        tempCtx.fillStyle = '#000';
        
        // 关键修复：移除 'lighter'，使用标准字重，确保笔画足够粗能被采样到
        tempCtx.font = `${fontSize}px "Noto Serif SC", serif`; 
        tempCtx.textAlign = 'center';
        tempCtx.textBaseline = 'middle';
        tempCtx.fillText(term, canvasW/2, canvasH/2);
        
        const imageData = tempCtx.getImageData(0, 0, canvasW, canvasH);
        const data = imageData.data;
        
        const gap = CONFIG.textGap; 
        
        for(let py = 0; py < canvasH; py += gap){
            for(let px = 0; px < canvasW; px += gap){
                // 关键修复：降低透明度阈值 (180 -> 50)
                // 只要有点颜色就生成粒子，确保细小的笔画也能显示出来
                if(data[(py * canvasW + px) * 4 + 3] > 50){
                    let textLocalX = px - canvasW/2;
                    let textLocalY = py - canvasH/2;
                    let charAngle = angle + Math.PI / 2;
                    let rotatedTextX = textLocalX * Math.cos(charAngle) - textLocalY * Math.sin(charAngle);
                    let rotatedTextY = textLocalX * Math.sin(charAngle) + textLocalY * Math.cos(charAngle);
                    let finalX = x + rotatedTextX;
                    let finalY = y + rotatedTextY;
                    
                    particlesArray.push(new Particle(finalX, finalY, CONFIG.colors.text));
                }
            }
        }
    });
}

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    angleGlobal += CONFIG.rotationSpeed;
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    const cos = Math.cos(angleGlobal);
    const sin = Math.sin(angleGlobal);

    const len = particlesArray.length;
    for (let i = 0; i < len; i++) {
        particlesArray[i].update(centerX, centerY, cos, sin);
    }
    
    requestAnimationFrame(animate);
}

// 启动
init();
animate();

</script>
</body>
</html>
