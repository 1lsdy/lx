<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>二十四节气 - 粒子交互可视化</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #e0e0e0; /* 4. 背景调亮 (原 #cccccc -> #e0e0e0) */
            overflow: hidden;
            font-family: 'Noto Serif SC', 'Songti SC', serif;
        }
        canvas {
            display: block;
        }
        /* 新增：分享按钮样式 */
        #share-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            padding: 10px 24px;
            background-color: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 30px;
            color: #555;
            font-family: 'Noto Serif SC', serif;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            z-index: 100;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }
        #share-btn:active {
            transform: scale(0.95);
            background-color: rgba(255, 255, 255, 0.9);
        }
        /* 新增：提示框样式 */
        #toast {
            position: absolute;
            bottom: 80px;
            right: 30px;
            padding: 8px 16px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 101;
        }
    </style>
</head>
<body>

<canvas id="canvas1"></canvas>
<!-- 新增：分享按钮与提示框 -->
<button id="share-btn">分享作品</button>
<div id="toast">链接已复制</div>

<script>
/**
 * 配置参数
 */
const CONFIG = {
    // --- 粒子数量控制 ---
    petalCount: 6000,         // 花瓣构成粒子数
    bgCount: 3500,            // 背景金色氛围粒子数
    ringCount: 4000,          // 1. 外圈圆环粒子数改为 4000
    outerBorderCount: 1200,   // 最外层黄色装饰圈粒子数
    textGap: 1,               // 文字采样间隔
    
    // --- 视觉参数 ---
    particleSize: 1.4,        // 2. 粒子大小调大 (原 1.1 -> 1.4)
    returnSpeed: 0.08,        // 粒子归位速度
    friction: 0.94,           // 摩擦力
    
    // --- 动画参数 ---
    rotationSpeed: 0.0003,    // 圆盘整体旋转速度
    
    colors: {
        winter: '#1B2640',    // 冬 - 深蓝
        spring: '#009E73',    // 春 - 翠绿
        summer: '#D94430',    // 夏 - 朱红
        autumn: '#FFFFFF',    // 秋 - 纯白
        bgInner: '#E6A54E',   // 内部底色 - 金黄
        textRing: '#FFFFFF',  // 1. 圆环改为纯白 (原 #999999)
        outerBorder: '#E6A54E', // 最外圈黄色
        text: '#333333'       // 文字颜色
    }
};

const canvas = document.getElementById('canvas1');
const ctx = canvas.getContext('2d');

let particlesArray = [];
let solarTerms = [
    "立春", "雨水", "惊蛰", "春分", "清明", "谷雨",
    "立夏", "小满", "芒种", "夏至", "小暑", "大暑",
    "立秋", "处暑", "白露", "秋分", "寒露", "霜降",
    "立冬", "小雪", "大雪", "冬至", "小寒", "大寒"
];

// 全局动画状态
let angleGlobal = 0; // 整体旋转角度

// 适配窗口大小
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    init();
});

/**
 * 粒子类
 */
class Particle {
    constructor(x, y, color, type) {
        this.x = Math.random() * canvas.width; // 初始随机位置
        this.y = Math.random() * canvas.height;
        this.targetX = x; // 目标归位坐标 (相对于中心点)
        this.targetY = y;
        this.color = color;
        this.size = CONFIG.particleSize;
        this.type = type; 
        
        // 物理运动属性
        this.vx = 0;
        this.vy = 0;
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
    }

    update(centerX, centerY) {
        // 旋转变换逻辑
        const cos = Math.cos(angleGlobal);
        const sin = Math.sin(angleGlobal);
        
        const rotatedX = (this.targetX * cos) - (this.targetY * sin);
        const rotatedY = (this.targetX * sin) + (this.targetY * cos);

        // 最终目标屏幕坐标
        let destX = centerX + rotatedX;
        let destY = centerY + rotatedY;

        // 归位逻辑 (用于初始加载时的聚合动画)
        if (Math.abs(this.x - destX) > 0.1 || Math.abs(this.y - destY) > 0.1) {
            let dxMove = destX - this.x;
            let dyMove = destY - this.y;
            
            this.vx += dxMove * CONFIG.returnSpeed * 0.1;
            this.vy += dyMove * CONFIG.returnSpeed * 0.1;
            
            this.vx *= CONFIG.friction;
            this.vy *= CONFIG.friction;
            
            this.x += this.vx;
            this.y += this.vy;
        } else {
            // 锁定位置节省性能
            this.x = destX;
            this.y = destY;
            this.vx = 0;
            this.vy = 0;
        }

        this.draw();
    }
}

/**
 * 初始化场景
 */
function init() {
    particlesArray = [];
    
    const minDimension = Math.min(canvas.width, canvas.height);
    const radius = minDimension * 0.35; // 主半径
    
    // 提前定义圆环半径，供背景填充使用
    const ringInnerR = radius + 15;
    const ringOuterR = radius + 65;

    // 1. 生成花瓣 (Rose Curve)
    for (let i = 0; i < CONFIG.petalCount; i++) {
        let theta = Math.random() * Math.PI * 2;
        let rMax = Math.abs(Math.cos(2 * theta)) * radius;
        let r = Math.sqrt(Math.random()) * rMax;
        
        let x = r * Math.cos(theta);
        let y = r * Math.sin(theta);

        // 确定颜色
        let color = CONFIG.colors.bgInner; 
        let deg = (theta * 180 / Math.PI + 360) % 360;
        
        if (deg >= 315 || deg < 45) color = CONFIG.colors.spring;
        else if (deg >= 45 && deg < 135) color = CONFIG.colors.summer;
        else if (deg >= 135 && deg < 225) color = CONFIG.colors.autumn;
        else if (deg >= 225 && deg < 315) color = CONFIG.colors.winter;

        particlesArray.push(new Particle(x, y, color, 'petal'));
    }

    // 2. 生成背景圆盘填充 (避开花瓣)
    let bgParticlesCreated = 0;
    while (bgParticlesCreated < CONFIG.bgCount) {
        let theta = Math.random() * Math.PI * 2;
        
        // 2. 修改：生成半径从 radius 扩大到 ringInnerR，消除与圆环的间隙
        let r = Math.sqrt(Math.random()) * ringInnerR; 
        
        let petalBoundary = Math.abs(Math.cos(2 * theta)) * radius;

        if (r < petalBoundary * 1.02) {
            continue;
        }
        
        let x = r * Math.cos(theta);
        let y = r * Math.sin(theta);
        
        particlesArray.push(new Particle(x, y, CONFIG.colors.bgInner, 'bg'));
        bgParticlesCreated++;
    }

    // 3. 生成外圈文字环
    // (ringInnerR 和 ringOuterR 已在上方定义)
    
    for (let i = 0; i < CONFIG.ringCount; i++) {
        let theta = Math.random() * Math.PI * 2;
        let r = ringInnerR + Math.random() * (ringOuterR - ringInnerR);
        let x = r * Math.cos(theta);
        let y = r * Math.sin(theta);
        particlesArray.push(new Particle(x, y, CONFIG.colors.textRing, 'ring'));
    }

    // 4. 外围黄色粒子圈
    const borderR = ringOuterR + 5;
    for (let i = 0; i < CONFIG.outerBorderCount; i++) {
        let theta = Math.random() * Math.PI * 2;
        let r = borderR + Math.random() * 3; 
        let x = r * Math.cos(theta);
        let y = r * Math.sin(theta);
        particlesArray.push(new Particle(x, y, CONFIG.colors.outerBorder, 'border'));
    }

    // 5. 生成文字粒子
    createSolarTermsParticles(ringInnerR, ringOuterR);
}

function createSolarTermsParticles(innerR, outerR) {
    const textRadius = (innerR + outerR) / 2;
    
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = 100;
    tempCanvas.height = 50;

    solarTerms.forEach((term, index) => {
        let angle = (index - 3) * 15 * (Math.PI / 180);
        
        let x = textRadius * Math.cos(angle);
        let y = textRadius * Math.sin(angle);
        
        tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
        tempCtx.fillStyle = '#000';
        // 3. 字体变细：移除 'bold'，改为标准字体
        tempCtx.font = '20px "Noto Serif SC"'; 
        tempCtx.textAlign = 'center';
        tempCtx.textBaseline = 'middle';
        tempCtx.fillText(term, 50, 25);
        
        const imageData = tempCtx.getImageData(0, 0, 100, 50);
        const data = imageData.data;
        
        const gap = CONFIG.textGap; 
        
        for(let py = 0; py < 50; py += gap){
            for(let px = 0; px < 100; px += gap){
                if(data[(py * 100 + px) * 4 + 3] > 128){
                    let textLocalX = px - 50;
                    let textLocalY = py - 25;
                    let charAngle = angle + Math.PI / 2;
                    let rotatedTextX = textLocalX * Math.cos(charAngle) - textLocalY * Math.sin(charAngle);
                    let rotatedTextY = textLocalX * Math.sin(charAngle) + textLocalY * Math.cos(charAngle);
                    let finalX = x + rotatedTextX;
                    let finalY = y + rotatedTextY;
                    
                    particlesArray.push(new Particle(finalX, finalY, CONFIG.colors.text, 'text'));
                }
            }
        }
    });
}

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 更新全局变量
    angleGlobal += CONFIG.rotationSpeed;
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    particlesArray.forEach(particle => {
        particle.update(centerX, centerY);
    });
    
    requestAnimationFrame(animate);
}

// 启动
init();
animate();

// --- 新增：分享功能逻辑 ---
const shareBtn = document.getElementById('share-btn');
const toast = document.getElementById('toast');

shareBtn.addEventListener('click', async () => {
    const shareData = {
        title: '二十四节气 · 粒子视界',
        text: '邀你共赏：由粒子构成的二十四节气动态画卷',
        url: window.location.href
    };

    // 1. 优先尝试移动端原生分享
    if (navigator.share) {
        try {
            await navigator.share(shareData);
            return;
        } catch (err) {
            console.log('用户取消分享或分享失败', err);
        }
    }

    // 2. 降级方案：复制链接
    fallbackCopy(window.location.href);
});

function fallbackCopy(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.position = "fixed";  // 避免滚动到底部
    textArea.style.opacity = "0";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    let successful = false;
    try {
        successful = document.execCommand('copy');
    } catch (err) {
        console.error('无法复制', err);
    }
    
    document.body.removeChild(textArea);
    
    if (successful) {
        showToast('链接已复制');
    } else {
        showToast('请手动复制浏览器地址栏');
    }
}

function showToast(msg) {
    toast.textContent = msg;
    toast.style.opacity = '1';
    setTimeout(() => {
        toast.style.opacity = '0';
    }, 2000);
}

</script>
</body>
</html>