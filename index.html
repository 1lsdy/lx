<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>二十四节气 - 粒子交互可视化</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #e0e0e0; 
            overflow: hidden;
            font-family: 'Noto Serif SC', 'Songti SC', serif;
        }
        canvas {
            display: block;
        }
        /* 分享按钮样式 */
        #share-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            padding: 10px 24px;
            background-color: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 30px;
            color: #555;
            font-family: 'Noto Serif SC', serif;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            z-index: 100;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }
        #share-btn:active {
            transform: scale(0.95);
            background-color: rgba(255, 255, 255, 0.9);
        }
        /* 提示框样式 */
        #toast {
            position: absolute;
            bottom: 80px;
            right: 30px;
            padding: 8px 16px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 101;
        }
    </style>
</head>
<body>

<canvas id="canvas1"></canvas>
<button id="share-btn">分享作品</button>
<div id="toast">链接已复制</div>

<script>
// 检测是否为移动端 (屏幕宽度小于 768px)
const isMobile = window.innerWidth < 768;

/**
 * 动态配置参数
 * 根据设备类型自动调整性能参数
 */
const CONFIG = {
    // --- 粒子数量控制 (移动端大幅减量以保证流畅) ---
    petalCount: isMobile ? 1800 : 6000,         // 花瓣: 手机1800 / 电脑6000
    bgCount: isMobile ? 1200 : 3500,            // 背景: 手机1200 / 电脑3500
    ringCount: isMobile ? 1500 : 4000,          // 圆环: 手机1500 / 电脑4000
    outerBorderCount: isMobile ? 600 : 1200,    // 外框: 手机600 / 电脑1200
    
    // --- 字体与采样 ---
    // 手机端采样间隔设为2(稀疏)，电脑端设为1(密集)。
    // 稀疏的采样会让字体看起来更细。
    textGap: isMobile ? 2 : 1,               
    
    // --- 视觉参数 ---
    // 手机端粒子稍微调小一点点，显得精致
    particleSize: isMobile ? 1.3 : 1.4,        
    returnSpeed: 0.08,
    friction: 0.94,
    
    // --- 动画参数 ---
    rotationSpeed: 0.0003, 
    
    colors: {
        winter: '#1B2640',    // 冬
        spring: '#009E73',    // 春
        summer: '#D94430',    // 夏
        autumn: '#FFFFFF',    // 秋
        bgInner: '#E6A54E',   // 金黄
        textRing: '#FFFFFF',  // 圆环白
        outerBorder: '#E6A54E', // 外圈黄
        text: '#333333'       // 文字黑
    }
};

const canvas = document.getElementById('canvas1');
const ctx = canvas.getContext('2d');

let particlesArray = [];
let solarTerms = [
    "立春", "雨水", "惊蛰", "春分", "清明", "谷雨",
    "立夏", "小满", "芒种", "夏至", "小暑", "大暑",
    "立秋", "处暑", "白露", "秋分", "寒露", "霜降",
    "立冬", "小雪", "大雪", "冬至", "小寒", "大寒"
];

let angleGlobal = 0; 

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// 窗口大小改变时重置
let resizeTimeout;
window.addEventListener('resize', () => {
    // 防抖处理，避免手机滚动地址栏时频繁触发
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        // 重新判断是否移动端(应对横竖屏切换)
        const newIsMobile = window.innerWidth < 768;
        if (newIsMobile !== isMobile) {
            location.reload(); // 模式改变时刷新页面以应用新配置
        } else {
            init();
        }
    }, 200);
});

class Particle {
    constructor(x, y, color) {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.targetX = x; 
        this.targetY = y;
        this.color = color;
        this.size = CONFIG.particleSize;
        
        this.vx = 0;
        this.vy = 0;
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        // 性能优化：小粒子绘制
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }

    update(centerX, centerY, cos, sin) {
        // 预计算的 cos/sin 传入，避免重复计算
        const rotatedX = (this.targetX * cos) - (this.targetY * sin);
        const rotatedY = (this.targetX * sin) + (this.targetY * cos);

        let destX = centerX + rotatedX;
        let destY = centerY + rotatedY;

        // 简化的物理逻辑：仅计算归位，不做其他交互
        if (Math.abs(this.x - destX) > 0.5 || Math.abs(this.y - destY) > 0.5) {
            let dx = destX - this.x;
            let dy = destY - this.y;
            this.vx += dx * CONFIG.returnSpeed * 0.1;
            this.vy += dy * CONFIG.returnSpeed * 0.1;
            this.vx *= CONFIG.friction;
            this.vy *= CONFIG.friction;
            this.x += this.vx;
            this.y += this.vy;
        } else {
            // 归位后强制锁定，大幅提升性能
            this.x = destX;
            this.y = destY;
            this.vx = 0;
            this.vy = 0;
        }

        this.draw();
    }
}

function init() {
    particlesArray = [];
    
    const minDimension = Math.min(canvas.width, canvas.height);
    
    // --- 响应式尺寸计算 (关键修复) ---
    // 手机上使用更保守的半径比例，防止被截断
    // 电脑: 0.35, 手机: 0.28 (留出更多边缘)
    const radiusScale = isMobile ? 0.28 : 0.35; 
    const radius = minDimension * radiusScale; 
    
    // 圆环宽度不再是固定像素，而是基于半径的比例
    // 这样保证无论屏幕多小，圆环都按比例缩小
    const ringGap = radius * 0.05; // 间隙
    const ringWidth = radius * 0.25; // 圆环宽度
    
    const ringInnerR = radius + ringGap;
    const ringOuterR = radius + ringGap + ringWidth;

    // 1. 生成花瓣
    for (let i = 0; i < CONFIG.petalCount; i++) {
        let theta = Math.random() * Math.PI * 2;
        let rMax = Math.abs(Math.cos(2 * theta)) * radius;
        let r = Math.sqrt(Math.random()) * rMax;
        
        let x = r * Math.cos(theta);
        let y = r * Math.sin(theta);

        let color = CONFIG.colors.bgInner; 
        let deg = (theta * 180 / Math.PI + 360) % 360;
        
        if (deg >= 315 || deg < 45) color = CONFIG.colors.spring;
        else if (deg >= 45 && deg < 135) color = CONFIG.colors.summer;
        else if (deg >= 135 && deg < 225) color = CONFIG.colors.autumn;
        else if (deg >= 225 && deg < 315) color = CONFIG.colors.winter;

        particlesArray.push(new Particle(x, y, color));
    }

    // 2. 生成背景圆盘 (消除间隙，填充到 ringInnerR)
    let bgParticlesCreated = 0;
    while (bgParticlesCreated < CONFIG.bgCount) {
        let theta = Math.random() * Math.PI * 2;
        let r = Math.sqrt(Math.random()) * ringInnerR; 
        
        let petalBoundary = Math.abs(Math.cos(2 * theta)) * radius;

        if (r < petalBoundary * 1.02) {
            continue;
        }
        
        let x = r * Math.cos(theta);
        let y = r * Math.sin(theta);
        
        particlesArray.push(new Particle(x, y, CONFIG.colors.bgInner));
        bgParticlesCreated++;
    }

    // 3. 生成外圈文字环
    for (let i = 0; i < CONFIG.ringCount; i++) {
        let theta = Math.random() * Math.PI * 2;
        let r = ringInnerR + Math.random() * (ringOuterR - ringInnerR);
        let x = r * Math.cos(theta);
        let y = r * Math.sin(theta);
        particlesArray.push(new Particle(x, y, CONFIG.colors.textRing));
    }

    // 4. 外围黄色装饰圈
    const borderR = ringOuterR + (isMobile ? 2 : 5);
    for (let i = 0; i < CONFIG.outerBorderCount; i++) {
        let theta = Math.random() * Math.PI * 2;
        let r = borderR + Math.random() * (isMobile ? 2 : 3); 
        let x = r * Math.cos(theta);
        let y = r * Math.sin(theta);
        particlesArray.push(new Particle(x, y, CONFIG.colors.outerBorder));
    }

    // 5. 生成文字粒子
    createSolarTermsParticles(ringInnerR, ringOuterR);
}

function createSolarTermsParticles(innerR, outerR) {
    const textRadius = (innerR + outerR) / 2;
    
    // 动态调整字体大小：手机上稍微小一点
    const fontSize = isMobile ? 14 : 20;
    // 临时画布尺寸自适应
    const canvasW = isMobile ? 80 : 100;
    const canvasH = isMobile ? 40 : 50;

    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = canvasW;
    tempCanvas.height = canvasH;

    solarTerms.forEach((term, index) => {
        let angle = (index - 3) * 15 * (Math.PI / 180);
        
        let x = textRadius * Math.cos(angle);
        let y = textRadius * Math.sin(angle);
        
        tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
        tempCtx.fillStyle = '#000';
        // 字体变细：手机端使用 lighter 权重，且字号调小
        tempCtx.font = `lighter ${fontSize}px "Noto Serif SC"`; 
        tempCtx.textAlign = 'center';
        tempCtx.textBaseline = 'middle';
        tempCtx.fillText(term, canvasW/2, canvasH/2);
        
        const imageData = tempCtx.getImageData(0, 0, canvasW, canvasH);
        const data = imageData.data;
        
        const gap = CONFIG.textGap; 
        
        for(let py = 0; py < canvasH; py += gap){
            for(let px = 0; px < canvasW; px += gap){
                // 提高阈值(>180)，只取字体笔画最黑的部分，让字体看起来更细
                if(data[(py * canvasW + px) * 4 + 3] > 180){
                    let textLocalX = px - canvasW/2;
                    let textLocalY = py - canvasH/2;
                    let charAngle = angle + Math.PI / 2;
                    let rotatedTextX = textLocalX * Math.cos(charAngle) - textLocalY * Math.sin(charAngle);
                    let rotatedTextY = textLocalX * Math.sin(charAngle) + textLocalY * Math.cos(charAngle);
                    let finalX = x + rotatedTextX;
                    let finalY = y + rotatedTextY;
                    
                    particlesArray.push(new Particle(finalX, finalY, CONFIG.colors.text));
                }
            }
        }
    });
}

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    angleGlobal += CONFIG.rotationSpeed;
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    // 预计算三角函数，减少 Math 调用次数
    const cos = Math.cos(angleGlobal);
    const sin = Math.sin(angleGlobal);

    const len = particlesArray.length;
    for (let i = 0; i < len; i++) {
        particlesArray[i].update(centerX, centerY, cos, sin);
    }
    
    requestAnimationFrame(animate);
}

// 启动
init();
animate();

// --- 分享功能 ---
const shareBtn = document.getElementById('share-btn');
const toast = document.getElementById('toast');

shareBtn.addEventListener('click', async () => {
    const shareData = {
        title: '二十四节气 · 粒子视界',
        text: '邀你共赏：由粒子构成的二十四节气动态画卷',
        url: window.location.href
    };

    if (navigator.share) {
        try {
            await navigator.share(shareData);
            return;
        } catch (err) {
            console.log('Share canceled', err);
        }
    }
    fallbackCopy(window.location.href);
});

function fallbackCopy(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.position = "fixed"; 
    textArea.style.opacity = "0";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    let successful = false;
    try {
        successful = document.execCommand('copy');
    } catch (err) {
        console.error('Copy failed', err);
    }
    
    document.body.removeChild(textArea);
    
    if (successful) {
        showToast('链接已复制');
    } else {
        showToast('请手动复制链接');
    }
}

function showToast(msg) {
    toast.textContent = msg;
    toast.style.opacity = '1';
    setTimeout(() => {
        toast.style.opacity = '0';
    }, 2000);
}
</script>
</body>
</html>
